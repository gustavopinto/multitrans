@inproceedings{Schafer:2010,
 author = {Max Schafer, Julian Dolby, Manu Sridharan, Emina Torlak, Frank Tip},
 title = {Correct refactoring of concurrent java code},
 booktitle = {Proceedings of the 24th European conference on Object-oriented programming},
 series = {ECOOP'10},
 year = {2010},
 isbn = {3-642-14106-4, 978-3-642-14106-5},
 location = {Maribor, Slovenia},
 pages = {225--249},
 numpages = {25},
 url = {http://dl.acm.org/citation.cfm?id=1883978.1883994},
 acmid = {1883994},
 publisher = {Springer-Verlag},
 address = {Berlin, Heidelberg},
 abstract = Automated refactorings as implemented in modern IDEs for Java usually make no special provisions for concurrent code. Thus, refactored programs may exhibit unexpected new concurrent behaviors. We analyze the types of such behavioral changes caused by current refactoring engines and develop techniques to make them behavior-preserving, ranging from simple techniques to deal with concurrency-related language constructs to a framework that computes and tracks synchronization dependencies. By basing our development directly on the Java Memory Model, we can state and prove precise correctness results about refactoring concurrent programs. We show that a broad range of refactorings are not influenced by concurrency at all, whereas other important refactorings can be made behavior-preserving for correctly synchronized programs by using our framework. Experience with a prototype implementation shows that our techniques are easy to implement and require only minimal changes to existing refactoring engines.
} 

@inproceedings{Dig:2009,
 author = {Danny Dig, John Marrero and Michael D. Ernst},
 title = {Refactoring sequential Java code for concurrency via concurrent libraries},
 booktitle = {Proceedings of the 31st International Conference on Software Engineering},
 series = {ICSE '09},
 year = {2009},
 isbn = {978-1-4244-3453-4},
 pages = {397--407},
 numpages = {11},
 url = {http://dx.doi.org/10.1109/ICSE.2009.5070539},
 doi = {http://dx.doi.org/10.1109/ICSE.2009.5070539},
 acmid = {1555054},
 publisher = {IEEE Computer Society},
 address = {Washington, DC, USA},
 abstract = Parallelizing existing sequential programs to run efficiently on multicores is hard. The Java 5 package java.util.concurrent (j.u.c.) supports writing concurrent programs: much of the complexity of writing threads-safe and scalable programs is hidden in the library. To use this package, programmers still need to reengineer existing code. This is tedious because it requires changing many lines of code, is error-prone because programmers can use the wrong APIs, and is omission-prone because programmers can miss opportunities to use the enhanced APIs. This paper presents our tool, CONCURRENCER, which enables programmers to refactor sequential code into parallel code that uses j.u.c. concurrent utilities. CONCURRENCER does not require any program annotations, although the transformations are very involved: they span multiple program statements and use custom program analysis. A find-and-replace tool can not perform such transformations. Empirical evaluation shows that C ONCURRENCER refactors code effectively: CONCURRENCER correctly identifies and applies transformations that some open-source developers overlooked, and the converted code exhibits good speedup.
} 

@inproceedings{Wloka:2009,
 author = {Jan Wloka, Manu Sridharan and Frank Tip},
 title = {Refactoring for reentrancy},
 booktitle = {Proceedings of the the 7th joint meeting of the European software engineering conference and the ACM SIGSOFT symposium on The foundations of software engineering},
 series = {ESEC/FSE '09},
 year = {2009},
 isbn = {978-1-60558-001-2},
 location = {Amsterdam, The Netherlands},
 pages = {173--182},
 numpages = {10},
 url = {http://doi.acm.org/10.1145/1595696.1595723},
 doi = {http://doi.acm.org/10.1145/1595696.1595723},
 acmid = {1595723},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {program transformation, reentrant code, refactoring},
 abstract = A program is reentrant if distinct executions of that program on distinct inputs cannot affect each other. Reentrant programs have the desirable property that they can be deployed on parallel machines without additional concurrency control. Many existing Java programs are not reentrant because they rely on mutable global state. We present a mostly-automated refactoring that makes such programs reentrant by replacing global state with thread-local state and performing each execution in a fresh thread. The approach has the key advantage of yielding a program that is obviously safe for parallel execution; the program can then be optimized selectively for better performance. We implemented this refactoring in Reentrancer, a practical Eclipse-based tool. Reentrancer successfully eliminated observed reentrancy problems in five single-threaded Java benchmarks. For three of the benchmarks, Reentrancer enabled speedups on a multicore machine without any further code modification.
} 

@inproceedings{Ishizaki:2011,
 author = {Kazuaki Ishizaki, Shahrokh Daijavad, and Toshio Nakatani},
 title = {Refactoring Java programs using concurrent libraries},
 booktitle = {Proceedings of the Workshop on Parallel and Distributed Systems: Testing, Analysis, and Debugging},
 series = {PADTAD '11},
 year = {2011},
 isbn = {978-1-4503-0809-0},
 location = {Toronto, Ontario, Canada},
 pages = {35--44},
 numpages = {10},
 url = {http://doi.acm.org/10.1145/2002962.2002970},
 doi = {http://doi.acm.org/10.1145/2002962.2002970},
 acmid = {2002970},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {Java, concurrent library, pointer analysis, refactoring},
 abstract = Multithread programming is becoming ever-more important to exploit the capabilities of multicore processors. Versions of Java prior to version 5 provide only the synchronized construct as a consistency primitive, which causes a performance scalability problem for multicore machines. Therefore, Java 5 added the java.util.concurrent package to reduce lock contention. Programmers must manually rewrite their existing code to use this package in existing programs. There are two typical rewritings methods. One is to replace an operation on a variable within a synchronized block with an atomic-lock-free version. The other is to replace a sequential concurrent class with its concurrent version. The conventional rewriting approach has three deficiencies. One problem is transformations that may change the behavior of a program. The second problem is missed modifications to be rewritten. The third problem is two difference writing techniques are applied individually to each code fragment even in the same method. This paper describes our refactoring algorithms that address these three problems as they rewrite Java code for scalable performance. We use inter-procedural pointer analysis and consistency tests among the candidate code fragments.
} 


@inproceedings{Schafer:2011,
 author = {Max Schafer, Manu Sridharan, Julian Dolby, Frank Tip},
 title = {Refactoring Java programs for flexible locking},
 booktitle = {Proceedings of the 33rd International Conference on Software Engineering},
 series = {ICSE '11},
 year = {2011},
 isbn = {978-1-4503-0445-0},
 location = {Waikiki, Honolulu, HI, USA},
 pages = {71--80},
 numpages = {10},
 url = {http://doi.acm.org/10.1145/1985793.1985804},
 doi = {http://doi.acm.org/10.1145/1985793.1985804},
 acmid = {1985804},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {monitors, read-write locks, refactoring},
 abstract = Recent versions of the Java standard library offer flexible locking constructs that go beyond the language’s built-in monitor locks in terms of features, and that can be fine-tuned to suit specific application scenarios. Under certain conditions, the use of these constructs can improve performance significantly, by reducing lock contention. However, the code transformations needed to convert between locking constructs are non-trivial, and great care must be taken to update lock usage throughout the program consistently. We present Relocker, an automated tool that assists programmers with refactoring synchronized blocks into ReentrantLocks and ReadWriteLocks, to make exploring the performance tradeoffs among these constructs easier. In experiments on a collection of real-world Java applications, Relocker was able to refactor over 80\% of built-in monitors into ReentrantLocks. Additionally, in most cases the tool could automatically infer the same ReadWriteLock usage that programmers had previously introduced manually.
} 


@inproceedings{Torres:2011:JPT:2095050.2095072,
 author = {Weslley Torres, Gustavo Pinto, Benito Fernandes, João Paulo de Oliveira, Filipe Ximenes and Fernando Castor},
 title = {Are Java programmers transitioning to multicore?: a large scale study of java FLOSS},
 booktitle = {Proceedings of the compilation of the co-located workshops on DSM'11, TMC'11, AGERE!'11, AOOPES'11, NEAT'11, VMIL'11},
 series = {SPLASH '11 Workshops},
 year = {2011},
 isbn = {978-1-4503-1183-0},
 location = {Portland, Oregon, USA},
 pages = {123--128},
 numpages = {6},
 url = {http://doi.acm.org/10.1145/2095050.2095072},
 doi = {10.1145/2095050.2095072},
 acmid = {2095072},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {concurrent, java, multicore, open-source, parallel},
 abstract = {We would like to know if Java developers are retrofitting applications to become concurrent and, to get better performance on multicore machines. Also, we would like to know what concurrent programming constructs they currently use. Evidence of how programmers write concurrent programs can help other programmers to be more efficient when using the available constructs. Moreover, this evidence can assist researchers in devising new mechanisms and improving existing ones. For this purpose, we have conducted a study targeting a large-scale Java open source repository, SourceForge. We have analyzed a number of FLOSS projects along two dimensions: spatial and temporal. For the spatial dimension, we studied the latest versions of more than 2000 projects. Our goal is to understand which constructs developers of concurrent systems employ and how frequently they use them. For the temporal dimension we took a closer look at various versions of six projects and analyzed how the use of concurrency constructs has evolved over time. In addition, we tried to establish if uses of concurrency control constructs were aimed at leveraging multicore processors. We have downloaded more than two thousand Java projects including their various versions, in addition to individual analysing about six well known open-source projects.}
} 

@inproceedings{Brown:2011,
 author = {Brown, C. M., Hammond, K. & Loidl, H.},
 title = {Paraforming: Forming Parallel Haskell Programs Using Novel Refactoring Techniques},
 booktitle = {Trends in Functional Programming},
 series = {TFP'11},
 url = {http://blogs.cs.st-andrews.ac.uk/csblog/2011/09/27/functional-programming-by-prof-kevin-hammond/}
 year = {2011},
 numpages = {16},
 publisher = {Springer-Verlag},
 address = {Madrid, Spain},
 abstract = {Despite Moore’s “law”, uniprocessor clock speeds have now stalled. Rather than using single processors running at ever higher clock speeds, it is common to find dual-, quad- or even hexa-core processors, even in consumer laptops and desktops. Future hardware will not be slightly parallel, however, as in today’s multicore systems, but will be massively parallel, with manycore and perhaps even megacore systems becoming mainstream. This means that programmers need to start thinking parallel. To achieve this they must move away from traditional programming models and development processes that offer parallelism as an bolted-on afterthought.

This talk introduces the idea of “paraforming”, a new approach to constructing parallel functional programs using formally-defined refactoring transformations. We show how parallel programs can be built from a small number of primitive Haskell building blocks, and describe some new refactorings for Parallel Haskell that capture common parallel abstractions, such as divide-and-conquer and data parallelism using these building blocks. Using a paraforming approach, we are able to easily obtain significant and scalable speedups (up to 7.8 on an 8-core machine).}
} 

@inproceedings{Dig:2009:RRL:1639950.1640018,
 author = {Dig, Danny and Tarce, Mihai and Radoi, Cosmin and Minea, Marius and Johnson, Ralph},
 title = {Relooper: refactoring for loop parallelism in Java},
 booktitle = {Proceedings of the 24th ACM SIGPLAN conference companion on Object oriented programming systems languages and applications},
 series = {OOPSLA '09},
 year = {2009},
 isbn = {978-1-60558-768-4},
 location = {Orlando, Florida, USA},
 pages = {793--794},
 numpages = {2},
 url = {http://doi.acm.org/10.1145/1639950.1640018},
 doi = {10.1145/1639950.1640018},
 acmid = {1640018},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {concurrency, parallelism, program analysis, program transformation, refactoring},
 abstract = {In the multicore era, sequential programs need to be refactored for parallelism. The next version of Java provides ParallelArray, an array datastructure that supports parallel operations over the array elements. For example, one can apply a procedure to each element, or reduce all elements to a new element in parallel. Refactoring an array to a ParallelArray requires (i) analyzing whether the loop iterations are safe for parallel execution, and (ii) replacing loops with the equivalent parallel operations. When done manually, these tasks are non-trivial and time-consuming. This demo presents ReLooper, an Eclipse-based refactoring tool, that performs these tasks automatically. Preliminary experience with refactoring real programs shows that ReLooper is useful.}
} 

@inproceedings{Dig:2011:RAP:1920042.1920077,
 author = {Dig, Danny},
 title = {A Refactoring Approach to Parallelism},
 abstract = {In the multicore era, a major programming task will be to make programs more parallel. This is tedious because it requires changing many lines of code; it's also error-prone and nontrivial because programmers need to ensure noninterference of parallel operations. Fortunately, interactive refactoring tools can help reduce the analysis and transformation burden. The author describes how refactoring tools can improve programmer productivity, program performance, and program portability. The article also describes a toolset that supports several refactorings for making programs thread-safe, threading sequential programs for throughput, and improving scalability of parallel programs.}
 journal = {IEEE Softw.},
 issue_date = {January 2011},
 volume = {28},
 number = {1},
 month = jan,
 year = {2011},
 issn = {0740-7459},
 pages = {17--22},
 numpages = {6},
 url = {http://dx.doi.org/10.1109/MS.2011.1},
 doi = {10.1109/MS.2011.1},
 acmid = {1920077},
 booktitle = {IEEE Computer Society Press},
 address = {Los Alamitos, CA, USA},
 keywords = {refactoring, parallelism, concurrency},
} 

@inproceedings{Kjolstad:2011:TCI:1985793.1985803,
 author = {Kjolstad, Fredrik and Dig, Danny and Acevedo, Gabriel and Snir, Marc},
 title = {Transformation for class immutability},
 booktitle = {Proceedings of the 33rd International Conference on Software Engineering},
 series = {ICSE '11},
 year = {2011},
 isbn = {978-1-4503-0445-0},
 location = {Waikiki, Honolulu, HI, USA},
 pages = {61--70},
 numpages = {10},
 url = {http://doi.acm.org/10.1145/1985793.1985803},
 doi = {http://doi.acm.org/10.1145/1985793.1985803},
 acmid = {1985803},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {immutability, program transformation},
 abstract = {It is common for object-oriented programs to have both mutable and immutable classes. Immutable classes simplify programing because the programmer does not have to reason about side-effects. Sometimes programmers write immutable classes from scratch, other times they transform mutable into immutable classes. To transform a mutable class, programmers must find all methods that mutate its transitive state and all objects that can enter or escape the state of the class. The analyses are non-trivial and the rewriting is tedious. Fortunately, this can be automated.

We present an algorithm and a tool, Immutator, that enables the programmer to safely transform a mutable class into an immutable class. Two case studies and one controlled experiment show that Immutator is useful. It (i) reduces the burden of making classes immutable, (ii) is fast enough to be used interactively, and (iii) is much safer than manual transformations.}
} 

@inproceedings{Okur:FSE,
  author    = {Semih Okur and
               Danny Dig},
  title     = {How do developers use parallel libraries?},
  booktitle = {SIGSOFT FSE},
  year      = {2012},
  pages     = {54},
  ee        = {http://doi.acm.org/10.1145/2393596.2393660},
  crossref  = {DBLP:conf/sigsoft/2012},
  bibsource = {DBLP, http://dblp.uni-trier.de},
  abstract = {Parallel programming is hard. The industry leaders hope to convert the hard problem of using parallelism into the easier problem of using a parallel library. Yet, we know little about how programmers adopt these libraries in practice. Without such knowledge, other programmers cannot educate themselves about the state of the practice, library designers are unaware of API misusage, researchers make wrong assumptions, and tool vendors do not support common usage of library constructs. We present the first study that analyzes the usage of parallel libraries in a large scale experiment. We analyzed 655 open-source applications that use Microsoft’s new parallel libraries – Task Parallel Library (TPL) and Parallel Language Integrated Query (PLINQ) – comprising 17.6M lines of code written in C#. These applications are developed by 1609 programmers. Using this data, we uncover some interesting facts. For example, (i) for two of the fundamental parallel constructs, in at least 10\% of the cases developers misuse them so that the code runs sequentially instead of concurrently, (ii) developers make their parallel code more complex than it needs to be, (iii) parallel library usage follows a power-law distribution: 10\% of the API methods account for 90\% of the total usage. The TPL library designers confirmed that our finding are useful and will influence the future development of the library.}
}
