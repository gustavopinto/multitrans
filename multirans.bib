@inproceedings{Schafer:2010,
 author = {Max Schafer, Julian Dolby, Manu Sridharan, Emina Torlak, Frank Tip},
 title = {Correct refactoring of concurrent java code},
 booktitle = {Proceedings of the 24th European conference on Object-oriented programming},
 series = {ECOOP'10},
 year = {2010},
 isbn = {3-642-14106-4, 978-3-642-14106-5},
 location = {Maribor, Slovenia},
 pages = {225--249},
 numpages = {25},
 url = {http://dl.acm.org/citation.cfm?id=1883978.1883994},
 acmid = {1883994},
 publisher = {Springer-Verlag},
 address = {Berlin, Heidelberg},
 abstract = Automated refactorings as implemented in modern IDEs for Java usually make no special provisions for concurrent code. Thus, refactored programs may exhibit unexpected new concurrent behaviors. We analyze the types of such behavioral changes caused by current refactoring engines and develop techniques to make them behavior-preserving, ranging from simple techniques to deal with concurrency-related language constructs to a framework that computes and tracks synchronization dependencies. By basing our development directly on the Java Memory Model, we can state and prove precise correctness results about refactoring concurrent programs. We show that a broad range of refactorings are not influenced by concurrency at all, whereas other important refactorings can be made behavior-preserving for correctly synchronized programs by using our framework. Experience with a prototype implementation shows that our techniques are easy to implement and require only minimal changes to existing refactoring engines.
} 

@inproceedings{Dig:2009,
 author = {Danny Dig, John Marrero and Michael D. Ernst},
 title = {Refactoring sequential Java code for concurrency via concurrent libraries},
 booktitle = {Proceedings of the 31st International Conference on Software Engineering},
 series = {ICSE '09},
 year = {2009},
 isbn = {978-1-4244-3453-4},
 pages = {397--407},
 numpages = {11},
 url = {http://dx.doi.org/10.1109/ICSE.2009.5070539},
 doi = {http://dx.doi.org/10.1109/ICSE.2009.5070539},
 acmid = {1555054},
 publisher = {IEEE Computer Society},
 address = {Washington, DC, USA},
 abstract = Parallelizing existing sequential programs to run efficiently on multicores is hard. The Java 5 package java.util.concurrent (j.u.c.) supports writing concurrent programs: much of the complexity of writing threads-safe and scalable programs is hidden in the library. To use this package, programmers still need to reengineer existing code. This is tedious because it requires changing many lines of code, is error-prone because programmers can use the wrong APIs, and is omission-prone because programmers can miss opportunities to use the enhanced APIs. This paper presents our tool, CONCURRENCER, which enables programmers to refactor sequential code into parallel code that uses j.u.c. concurrent utilities. CONCURRENCER does not require any program annotations, although the transformations are very involved: they span multiple program statements and use custom program analysis. A find-and-replace tool can not perform such transformations. Empirical evaluation shows that C ONCURRENCER refactors code effectively: CONCURRENCER correctly identifies and applies transformations that some open-source developers overlooked, and the converted code exhibits good speedup.
} 

@inproceedings{Wloka:2009,
 author = {Jan Wloka, Manu Sridharan and Frank Tip},
 title = {Refactoring for reentrancy},
 booktitle = {Proceedings of the the 7th joint meeting of the European software engineering conference and the ACM SIGSOFT symposium on The foundations of software engineering},
 series = {ESEC/FSE '09},
 year = {2009},
 isbn = {978-1-60558-001-2},
 location = {Amsterdam, The Netherlands},
 pages = {173--182},
 numpages = {10},
 url = {http://doi.acm.org/10.1145/1595696.1595723},
 doi = {http://doi.acm.org/10.1145/1595696.1595723},
 acmid = {1595723},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {program transformation, reentrant code, refactoring},
 abstract = A program is reentrant if distinct executions of that program on distinct inputs cannot affect each other. Reentrant programs have the desirable property that they can be deployed on parallel machines without additional concurrency control. Many existing Java programs are not reentrant because they rely on mutable global state. We present a mostly-automated refactoring that makes such programs reentrant by replacing global state with thread-local state and performing each execution in a fresh thread. The approach has the key advantage of yielding a program that is obviously safe for parallel execution; the program can then be optimized selectively for better performance. We implemented this refactoring in Reentrancer, a practical Eclipse-based tool. Reentrancer successfully eliminated observed reentrancy problems in five single-threaded Java benchmarks. For three of the benchmarks, Reentrancer enabled speedups on a multicore machine without any further code modification.
} 

@inproceedings{Ishizaki:2011,
 author = {Kazuaki Ishizaki, Shahrokh Daijavad, and Toshio Nakatani},
 title = {Refactoring Java programs using concurrent libraries},
 booktitle = {Proceedings of the Workshop on Parallel and Distributed Systems: Testing, Analysis, and Debugging},
 series = {PADTAD '11},
 year = {2011},
 isbn = {978-1-4503-0809-0},
 location = {Toronto, Ontario, Canada},
 pages = {35--44},
 numpages = {10},
 url = {http://doi.acm.org/10.1145/2002962.2002970},
 doi = {http://doi.acm.org/10.1145/2002962.2002970},
 acmid = {2002970},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {Java, concurrent library, pointer analysis, refactoring},
 abstract = Multithread programming is becoming ever-more important to exploit the capabilities of multicore processors. Versions of Java prior to version 5 provide only the synchronized construct as a consistency primitive, which causes a performance scalability problem for multicore machines. Therefore, Java 5 added the java.util.concurrent package to reduce lock contention. Programmers must manually rewrite their existing code to use this package in existing programs. There are two typical rewritings methods. One is to replace an operation on a variable within a synchronized block with an atomic-lock-free version. The other is to replace a sequential concurrent class with its concurrent version. The conventional rewriting approach has three deficiencies. One problem is transformations that may change the behavior of a program. The second problem is missed modifications to be rewritten. The third problem is two difference writing techniques are applied individually to each code fragment even in the same method. This paper describes our refactoring algorithms that address these three problems as they rewrite Java code for scalable performance. We use inter-procedural pointer analysis and consistency tests among the candidate code fragments.
} 


@inproceedings{Schafer:2011,
 author = {Max Schafer, Manu Sridharan, Julian Dolby, Frank Tip},
 title = {Refactoring Java programs for flexible locking},
 booktitle = {Proceedings of the 33rd International Conference on Software Engineering},
 series = {ICSE '11},
 year = {2011},
 isbn = {978-1-4503-0445-0},
 location = {Waikiki, Honolulu, HI, USA},
 pages = {71--80},
 numpages = {10},
 url = {http://doi.acm.org/10.1145/1985793.1985804},
 doi = {http://doi.acm.org/10.1145/1985793.1985804},
 acmid = {1985804},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {monitors, read-write locks, refactoring},
 abstract = Recent versions of the Java standard library offer flexible locking constructs that go beyond the language’s built-in monitor locks in terms of features, and that can be fine-tuned to suit specific application scenarios. Under certain conditions, the use of these constructs can improve performance significantly, by reducing lock contention. However, the code transformations needed to convert between locking constructs are non-trivial, and great care must be taken to update lock usage throughout the program consistently. We present Relocker, an automated tool that assists programmers with refactoring synchronized blocks into ReentrantLocks and ReadWriteLocks, to make exploring the performance tradeoffs among these constructs easier. In experiments on a collection of real-world Java applications, Relocker was able to refactor over 80\% of built-in monitors into ReentrantLocks. Additionally, in most cases the tool could automatically infer the same ReadWriteLock usage that programmers had previously introduced manually.
} 


@inproceedings{Torres:2011:JPT:2095050.2095072,
 author = {Weslley Torres, Gustavo Pinto, Benito Fernandes, João Paulo de Oliveira, Filipe Ximenes and Fernando Castor},
 title = {Are Java programmers transitioning to multicore?: a large scale study of java FLOSS},
 booktitle = {Proceedings of the compilation of the co-located workshops on DSM'11, TMC'11, AGERE!'11, AOOPES'11, NEAT'11, VMIL'11},
 series = {SPLASH '11 Workshops},
 year = {2011},
 isbn = {978-1-4503-1183-0},
 location = {Portland, Oregon, USA},
 pages = {123--128},
 numpages = {6},
 url = {http://doi.acm.org/10.1145/2095050.2095072},
 doi = {10.1145/2095050.2095072},
 acmid = {2095072},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {concurrent, java, multicore, open-source, parallel},
} 

@inproceedings{Brown:2011,
 author = {Brown, C. M., Hammond, K. & Loidl, H.},
 title = {Paraforming: Forming Parallel Haskell Programs Using Novel Refactoring Techniques},
 booktitle = {Trends in Functional Programming},
 series = {TFP'11},
 year = {2011},
 numpages = {16},
 publisher = {Springer-Verlag},
 address = {Madrid, Spain}
} 